자바스크립트
    HTML, CSS와 함께 웹을 구성하는 요소 중 하나.
    웹 브라우저에서 동작하는 유일한 프로그래밍 언어
    인터프리터 언어(개발자가 별도의 컴파일 작업을 수행하지 않음)
    대부분의 보던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합
    - 인터프리터는 소스코드를 즉시 실행
    - 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화
    -> 비교적 처리 속도가 느린 인터프리터의 단점을 해결
    -> 컴파일 단계에서 추가적인 시간이 필요함에도 불구하고 보다 빠른 코드의 실행이 가능함


    멀티 패러다임 프로그래밍 언어임
    -> 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원
    class, 상속, private가 없어서 객체지향 언어가 아니라고 오해하는 경우도 있지만
    class기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반 객체지향 언어임

    nodeJS의 등장으로 웹 브라우저를 벗어나 서버 사이드 앱 개발에서도
    사요되는 범용 개발 언어가 됨
    but 가장 많이 사용되는 분야는 웹 환경에서 동작하는 웹페이지/앱

    브라우저의 핵심 기능
    - 사용자가 참조하고자 하는 웹페이지를 소버에 요청(request)
    - 서버의 응답을 받아 브라우저에 표시(repond)
    
기본 문법
- 변수
    변수를 선언할 떄 var키워드를 사용
    var x; // 변수의 선언
    x = 6; // 정수값의 할당

- 값
    데이터 타입 : 사용할 수 있는 값의 종류
        number, string, boolean, null, undefined, symbol, object
        자바스트립트는 변수를 선언할 때 데이터 타입을 미리 지정하지 않음
        변수에 할당된 값의 타입에 의해 동적으로 결정됨 -> 동적 타이핑
    변수 : 값이 저장된 메모리 공간의 주소를 가리키는 식별자
    리터럴 : 소스코드 안에서 직접 만들어 낸 상수 값 자체를 말함. 값을 구성하는 최소 단위

    리터럴 vs 값
    리터럴 : 코드 안에서 값을 직접 표현하는 표기법. 값을 직접 써 놓은 형태
    값 : 프로그램 실행 중에 메모리에 저장되어 있는 데이터 자체. 실제 데이터

- 연산자
    알고있는것들과 동일함
    피연산자의 타입은 반드시 일치할 필요는 없음(암묵적 타입 강제변환을 하기 때문)
    ex. var foo = 1 + '10'; // '110'
        var bar = 1 * '10'; // 10

- 키워드
    : 수행할 동작을 규정한 것.
    
    // 변수의 선언
    var x = 0;

    // 함수의 선언
    function foo (arg){
        // 함수 종료 및 값의 반환
        return ++arg;
    }
    
    // 반복문, 조건문, break (기존과 동일)

- 문
    프로그램(스크립트)는 컴퓨터에 의해 단계별로 수행될 명령들의 집합.
    각각의 명령문을 문(statement)이라 하며 문이 실행되면 뭔가가 일어남
    문은 리터럴, 연산자, 표현식, 키워드 등으로 구성
    코드블록({...})으로 그룹화할 수 있음

- 표현식
    하나의 값으로 평가됨
    값(리터럴), 변수, 객체의 프로퍼티, 배열의 요소, 함수/메서드 호출,
    피연산자와 연산자의 조합이 해당됨
    ex.
    5 -> 5
    5 * 10 -> 50
    5 * 10 > 10 -> true

- 문과 표현식의 비교
    문 : 마침표로 끝나는 하나의 완전한 문장
    표현식 : 문을 구성하는 요소

    ex. 
    var x = 5 * 10; -> 표현식 x = 5 * 10을 포함하는 문
    x = 100; -> 이 자체가 표현식이지만 완전한 문이기도 함

- 함수
- 객체
    원시 타입을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체
    자바스크립트 객체는 키(이름)과 값으로 구성된 프로퍼티의 집합
    ex.
    var person = {
        name : 'Lee',
        gender : 'male',
        sayHello : function(){
            console.log('Hi My name is ' + this.name);
        }
    };

    console.log(typeof person); -> object
    console.log(person) -> {name:'Lee', gender ...}
    person.sayHello(); -> Hi My name is Lee

    -> 객체는 데이터를 의미하는 프로퍼티와
    데이터를 참조하고 조작할 수 있는 동작을 의미하는 메서드로 구성된 집합

- 배열
    var arr = [1, 2, 3, 4, 5];
    consloe.log(arr[1]); -> 2

데이터 타입과 변수
    자바스크립트는 동적타입 언어
    -> 변수의 타입 지정 없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정됨
    -> 변수는 고정된 타입이 없어서 같은 변수에 여러 타입의 값을 자율롭게 할당 가능
    var foo = 'string';
    console.log(typeof foo); // string
    foo = 1;
    console.log(typeof foo); // number

    - number
    다른 언어에서는 숫자의 형태를 구분하지만 자바스크립트는 하나
    그래서 2,8,16진수의 값을 참조하면 모두 10진수로 해석됨
    정수만을 위한 타입이 없고 모든 수를 실수처리 함
    정수로 표시된다 해도 사실은 실수 -> 정수로 표시되는 수 끼리 나눠도 실수가 나올수 있음
    Infinity(무한대), NaN(산술 연산 불가) -> 특별한 값 표현

    - string
    ' ' 또는 " " 안에 텍스트를 넣어 생성
    배열처럼 인덱스를 통해 접근 가능 -> 이런 특성을 유사 배열이라고 함
    한번 생성된 문자열은 read only로서 변경할 수 없음
    하지만 새로운 문자열을 재할당 하는것은 가능함

    - boolean
    null, undefined, 숫자 0은 false로 간주됨

    - undefined
    선언 이후 값을 할당하지 않은 변수.
    빈상태로 내버려두지 않고 undefined로 초기화 해주는거임

    - null
    의도적으로 변수에 값이 없다는 것을 명시할 떄 사용
    함수가 호출되었으나 유효한 값을 반환할 수 없는 경우 반환
    typeof로 확인해보면 object가 반환됨
    타입을 확인할 때에는 일치 연산자(===)를 사용해야함

    - symbol
    변경 불가능한 원시 타입의 값
    이름의 충돌 위험이 없는 유일한 객체의 주키를 만들기 위해 사용
    Symbol 함수를 호출해 생성. 심볼값은 다른 심볼값들과 다른 유일한 심볼값

    변수
    : var, let, const키워드를 사용하여 선언   
    var키워드로 선언한 변수는 중복 선언이 가능함
    이전 변수의 값을 덮어씀

    동적 타이핑
    : 변수의 타입 지정 없이 값이 할당되는 과정에서 자동으로 타입이 결정됨
    -> 같은 변수에 여러 타입의 값을 할당 할 수 있음
    var foo;

    console.log(typeof foo);  // undefined

    foo = null;
    console.log(typeof foo);  // object

    foo = {};
    console.log(typeof foo);  // object

    foo = 3;
    console.log(typeof foo);  // number

    foo = 3.14;
    console.log(typeof foo);  // number

    foo = 'Hi';
    console.log(typeof foo);  // string

    foo = true;
    console.log(typeof foo);  // boolean

    변수 호이스팅
    : 모든 선언문이 해당 scope의 선두로 옮겨진 것처럼 동작하는 특성
    -> 자바스크립트는 모든 선언문이 선언되기 이전에 참조 가능함
        변수의 3단계
        - 선언 단계
        : 변수객체에 변수를 등록. 이 변수 객체는 스코프가 참조하는 대상이 됨
        - 초기화 단계
        : 변수객체에 등록된 변수를 메모리에 할당. 변수는 undefined로 초기화됨
        - 할당 단계
        : undefined로 초기화된 변수에 실제값을 할당
    var 키워드로 선언된 변수는 선언과 초기화 단계가 한번에 이루어짐
    -> 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후 undefined로 초기화됨
    -> 변수 선언문 이전에 변수에 접근해도 변수객체에 변수가 존재하기 떄문에 에러 안남
        스코프
        - 함수 레벨 스코프
        : 함수 내에서 선언된 변수는 함수 내에서만 유효
        - 블록 레벨 스코프
        : 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효
    자바스크립트 변수는 블록레벨 스코프를 가지지 않고 함수레벨 스코프를 가짐
    but, let, const를 사용하면 블록 레벨 스코프를 사용할 수 있음. 나중에 나올거임

    var 키워드로 선언된 변수의 문제점
    - 함수레벨 스코프
        전역변수의 남발
        for문 초기화식에서 사용한 변수를 외부에서 참조 가능
    - var키워드 생략 허용
        의도하지 않은 변수의 전역화
    - 중복 선언 허용
        의도하지 않은 변수값 변경
    - 변수 호이스팅
        변수를 선언하기 전에 참조가 가능함

산술연산자
    기존에 알던것과 동일. 유의할거 몇개만!
    1 + true -> 2 (true가 1이됨)
    1 + false -> 1 (false가 0이됨)
    true + false -> 1
    1 + null -> 1 (null은 0이됨)
    1 + undefined -> NaN (undefined는 NaN가 됨)

비교연산자
    == : 동등비교 (5 == '5'하면 true나옴. 암묵적 타입변환함)
    '' == '0'           // false
    0 == ''             // true
    0 == '0'            // true

    false == 'false'    // false
    false == '0'        // true

    false == undefined  // false
    false == null       // false
    null == undefined   // true

    === : 일치비교 (타입, 값 비교)
    5 === 5   // true
    5 === '5' // false
    NaN === NaN // false -> NaN는 자신과 일치하지 않는 유일한 값이기 때문
    isNaN(NaN) // true

삼항 조건 연산자
    조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값

쉼표 연산자
    왼쪽 피연산자부터 차례대로 평가. 마지막 피연산자의 평가 결과를 반환

암묵적 타입변환
    문맥(context)을 고려하여 암묵적 타입 변환을 실행함
    + : 피연산자 중 하나 이상이 문자열일때 대부분 문자열로 타입 변환
    -, * : 동일한 조건에서 대부분 숙자 타입으로 변환
    단항연산자 + : 숫자타입의 값으로 변환. 배열, undefined  는 NaN이됨
    조건문에서
    - false로 변환되는 값 (falsy값): undefined, null, 0, NaN, 빈 문자열
    - true로 변환되는 값 (truthly값): falsy값 이외의 값

명시적 타입변환
    - 문자열로 바꾸기
    console.log(String(1));
    console.log((1).toString()); 
    console.log(1 + ''); // 문자열 연결 연산자 이용
    - 숫자로 바꾸기
    console.log(Number('0'));
    console.log(parseInt('-1'));      // 문자열만 변환 가능
    console.log(parseFloat('10.53')); // 문자열만 변환 가능
    console.log(+'0'); // + 단항 연결 연산자 이용
    console.log('0' * 1); // * 산술 연산자 이용
    -  boolean으로 바꾸기
    console.log(Boolean('x')); 
    console.log(!!'x'); // ! 부정논리 연산자 두번 사용

객체
    객체 생성(프로퍼티 포함)
    var person = {
        name: 'Lee',
        gender: 'male',
        sayHello: function () {
        console.log('Hi! My name is ' + this.name);
        }
    };

    객체 생성(프로퍼티 이후 추가)
    var person = new Object();
    // 프로퍼티 추가
    person.name = 'Lee';
    person.gender = 'male';
    person.sayHello = function () {
    console.log('Hi! My name is ' + this.name);
    };

    생성자 함수 -> 동일한 프로퍼티를 가진 객체 여러개 생성 편리
    // 생성자 함수
    function Person(name, gender) { // 생성자 함수 이름은 일반적으로 대문자로 시작
        this.name = name; // this는 생성자 함수가 생성할 인스턴스를 가리킴
        this.gender = gender;
        this.sayHello = function(){
        console.log('Hi! My name is ' + this.name);
        };
    }
    // 인스턴스의 생성
    var person1 = new Person('Lee', 'male');
    var person2 = new Person('Kim', 'female');

    프로퍼티 키
    : 문자열(빈 문자열 포함)을 지정함
    다른 타입의 값을 지정하면 암묵적으로 타입이 변환됨
    var person = {
        'first-name': 'Ung-mo', -> first-name 은 -를 사용한 표현식이어서 ''로 감쌈
        gender: 'male',
        function: 1
    };
    - 참조할떄
    person.gender 혹은 person['gender']
    연산자가 포함될떄는 person['first-name']
    숫자일때는 person[1] 혹은 person['1']
    객체에 존재하지 않는 프로퍼티를 참조하면 undefined
    - 갱신할때
    그냥 재할당 해주면 됨
    - 프로퍼티 동적 생성
    person.age = 20 이렇게 그냥 할당해주면 됨
    - 프로퍼티 삭제
    delete person.gender; 해주면됨

    for-in 문
    : 객체(혹은 배열)에 포함된 모든 프로퍼티에 대해 루프를 수행할 수있음
    for (var prop in person){
        console.log(person[prop]);
    } 이렇게 해주면 되는거임
    배열도 마찬가지
    for (var index in arr){
        console.log(arr[index]);
    }

    원시타입은 값으로 전달 -> 복사되어 전달됨 : pass-by-value
    객체타입은 동적으로 값이 변화 -> 어느정도의 메모리 공강을 확보해야하 하는지 모름
    -> 힙 메모리에 저장됨 
